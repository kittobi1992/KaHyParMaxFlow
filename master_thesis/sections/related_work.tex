%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Maximum Flow Algorithms}
\label{sec:max_flow}

The first serious analysis of the maximum flow problem emerged in 1955 during 
a study of transportation and communication networks by Harris \cite{harris1955}. 
He formulate the problem as follows: \\
\emph{Consider a rail network connecting two cities by way of a number of
intermediate cities, where each link of the network has a number assigned to
it representing its capacity. Assuming a steady state condition, find a maximal
flow from one given city to the other.} \\
He generalizes his model of railway traffic flow to the today known maximum 
flow problem. In this Section we present two types of algorithms to solve the
maximum flow problem defined in Section \ref{sec:applications}

\subsubsection{Augmenting-Path Algorithms}
\label{sec:aug_path}

An \emph{augmenting path} $P = \{v_1,\ldots,v_k\}$ is a path in $G_f$ with $v_1 = s$ and 
$v_k = t$ \cite{edmonds1972theoretical}. \autoref{img:maximum_flow_example}~illustrates such a path.
Since all $(v_i,v_{i+1}) \in G_f \Rightarrow r_f(v_i,v_{i+1}) > 0$. 
Therefore, we can increase the flow on all edges $(v_i,v_{i+1})$ by 
$\Delta f = \min_{i \in [1,\ldots,k-1]} r_f(v_i,v_{i+1})$. It can be shown that $f$ is not a
maximum flow, if an \emph{augmenting path} exists in $G_f$ \cite{edmonds1972theoretical}. \\
One way to calculate a maximum flow $f$ is to find \emph{augmenting paths} in $G_f$ as
long as their exist one. The algorithm was established by Ford and Fulkerson \cite{ford1956maximal} and
consists of two phases. First, we search for an \emph{augmenting path} $P = \{v_1,\ldots,v_k\}$
from $s$ to $t$, e.g. with a simple \DFS. In the \emph{augmentation} step, we increase the flow on each
edge $(v_i,v_{i+1})$ by $\Delta f$ and decrease the flow on each reverse edge $(v_{i+1},v_i)$
by $\Delta f$. If the capacities are integral, the algorithm always terminates. Since, we can find an \emph{augmenting
path} in $G_f$ with a simple \DFS~in \BigO{|V|+|E|} and increase the
flow on every path by at least one, the running time of the algorithm can be bounded by \BigO{|E||f_{max}|}.
We can construct instances, where the running time is \BigO{|E||f_{max}|} or even the maximum flow $|f_{max}|$ 
is exponential in the problem size. \\
Edmond and Karp \cite{edmonds1972theoretical} improved Ford \& Fulkerson algorithm by increasing the flow
along an \emph{augmenting path} of minimal length. A shortest path from $s$ to $t$ in a 
graph with unit lengths can be found by a simple \BFS~calculation. It can be shown, that the
total number of \emph{augmentations} is \BigO{|V||E|}. The running time of Edmond \& Karps
maximum flow algorithm is then given by \BigO{|V||E|^2}. A sample execution of the algorithm
is presented in \autoref{img:edmond_karp_example}.

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{../img/maximum_flow/edmond_karp_example.eps}
\caption{Sample execution of Edmond \& Karps maximum flow algorithm \cite{edmonds1972theoretical}.
         The network $G$ with its capacities $c$ (black values) and flow $f$ (red values) is illustrated
         on the left side. The residual graph $G$ with its \emph{residual capacities} $r_f$ (black values)
         is presented on the right side. In each step the current \emph{augmenting path} in $G_f$ is highlighted
         by a red path. }
\label{img:edmond_karp_example}
\end{figure}

\subsubsection{Push-Relabel Algorithm}
\label{sec:push_relabel}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Modelling Flows on Hypergraphs}
\label{sec:related_model_flow}


\subsubsection{Transforming Hypergraphs to Flow Networks}
\label{sec:related_lawler}

Consider the \emph{bipartite graph} representation $G_*(H)$ of a hypergraph $H$ (see Section \ref{sec:hypergraph}).
Hu and Moerder \cite{HuMoerder85} introduced node capacities in $G_*(H)$. Each hyperedge
node $e$ has a capacity equal to $\omega(e)$ and each hypernode node infinity capacity. 
Further, they showed that a minimum-weight $(s,t)$-vertex seperator in $G$
is equal with a minimum-weight $(s,t)$-cutset of a hypergraph $H$. 
Finding such a seperator is a flow problem and can be calculated with the flow network \ShortT{L} 
presented by Lawler \cite{lawler1973}:

\begin{definition}
Let $T_L$ be the transformation of a hypergraph \HypergraphDef~into 
a flow network \T{L} proposed by Lawler \cite{lawler1973}. \ShortT{L} is defined as follows:
\begin{enumerate}
\item $V_L = V \cup \bigcup\limits_{e \in E}\ \{e', e''\}$
\item $\forall e \in E$ we add a directed edge $(e',e'')$ 
      with capacity $c_H(e',e'') = \omega(e)$
\item $\forall v \in V$ we add two directed edges $(v, e')$ and 
      $(e'', v),\ \forall e \in I(v)$ with 
      capacity $c_L(v, e') = c_L(e'',v) = \infty$.
\end{enumerate} 
\end{definition}

An example of this transformation is shown in \autoref{img:lawler_transformation}.
\ShortT{L} is nearly equivalent to the transformation $T_V(G)$ described in Defintion \autoref{def:vertex_seperator_transformation}
except that we do not have to split the hypernodes $v \in V$ into $(v',v'')$. This is due to the fact, that
a hypernode cannot be in a minimum-capacity $(s,t)$-vertex seperator, because each $v \in V$ has
infinity capacity \cite{HuMoerder85}.
Therefore, a minimum-capacity $(s,t)$-cutset in \ShortT{L} is equal to a minimum $(s,t)$-vertex seperator $G$.
The resulting graph \ShortT{L} has $|V_L| = 2|V| + |E|$ nodes and $|E_L| = 2(\bar{e}+1)|E|$ edges, where
$\bar{e}$ is the average size of a hyperedge \cite{pistorius2003}. Using \emph{Edmond-Karps}
maximum flow algorithm (see Section \ref{sec:aug_path}) on flow network \ShortT{L} 
takes time \BigO{|V|^2|E|^2} \cite{lawler1973}. \\
A minimum-weight $(s,t)$-cutset of $H$ can be found by simlpy mapping the minimum-capacity
$(s,t)$-cutset to their corresponding hyperedges in $H$ (see Section \ref{sec:applications}). 
The corresponding bipartition are all hypernodes $v \in V$ \emph{reachable} from $s$ in the 
\emph{residual graph} of \ShortT{L} and the counterpart are all hypernodes not \emph{reachable}
from $s$ (\todo{proof? reference?}). \\
In this thesis we often have to mix up nodes and edges of $H$ and \ShortT{L}. If we use
$v \in V_L$, there also exist a corresponding $v \in V$. $v$ can be used in both contexts.
For all $e \in E$ there exists two corresponding nodes $e',e'' \in V_L$. $e'$ 
is called \emph{incomming hyperedge node} and $e''$ is called \emph{outgoing hyperedge node}. 
In some cases we need to treat $e',e'' \in V_L$ the same way as their corresponding 
hyperedge $e \in E$. E.g. $e_1' \cap e_2'$ or $e_1'' \cap e_2'$ should be the same as $e_1 \cap e_2$.
However, it should be clear out of the context which terminology is used.


\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{../img/network_transformation/lawler_transformation.eps}
\caption{Transformation of a hypergraph into a equivalent flow network by Lawler \cite{lawler1973}. Note,
capacity of the black edges in the flow network is $\infty$.}
\label{img:lawler_transformation}
\end{figure}

\subsubsection{Implicit Flow Calculation on Hypergraphs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Max-Flow-Min-Cut Based Local Search on Graphs}
\label{sec:flow_local_search_graph}

It seems naturals to utilize maximum flow computations to improve the cut metric of a 
given partition of a graph. Lang and Rao \cite{lang2004flow} uses an approach,
called \emph{Max-Flow Qoutient-cut Improvement} (MQI), to improve the cut
of a graph when metrics such as \emph{expansion} or \emph{conductance}
are used. For a given bipartition $(S,\bar{S})$, they find the best 
improvement among all bipartitions $(S',\bar{S'})$ such that $S' \subset S$
by constructing a flow problem. Andersen and Lang \cite{andersen2008algorithm}
proposed a flow-based improvement algorithm, called \emph{Improve},
which works similiar as MQI, but did not restrict the output of the 
partition on $S' \subset S$. However, both techniques can not guarantee 
that the resulting bipartition is balanced and only are applicable for $k=2$. \\
Schulz and Sanders \cite{sanders2011engineering} integrate flow-based approaches 
in their \emph{multilevel graph partitioning} framework \emph{KaFFPa}. In general,
they build a flow problem around a region $B$ of the cut and connect the \emph{border} 
of $B$ with the source resp. sink. $B$ is defined in such a way that the flow computation
yields to a feasible cut in the original graph. Many ideas of this work are used in this
thesis and adapted to hypergraphs. Therefore, we will give a detailed description
of the concepts and advanced techniques to improve the cut of a graph.

\todo{define expansion and conductance in preliminaries for graphs}

\subsubsection{Balanced Flow-Based Bipartitioning}
\label{sec:balanced_bipartitioning}
Let $(V_1,V_2)$ be a balanced bipartition of a graph $G = (V,E,c,\omega)$. 
Further, $P(v) = 1$, if $v \in V_1$ and
$P(v) = 2$, otherwise. We will now explain how to improve a given
bipartition with flow computations. This technique can also be applied on a $k$-way 
partition by applying the approach on two adjacent blocks in the qoutient graph \cite{sanders2011engineering}. \\
Let $\delta := \{ u\ |\ \exists (u,v) \in E: P(u) \neq P(v) \}$ be the set of nodes
around the cut of $G$. For a set $B \subseteq V$ we define its border 
$\delta B := \{u \in B\ |\ \exists (u,v) \in E: v \notin B\}$.
The basic idea is to build a flow problem on subgraph $G_B$ around all cut nodes $\delta$ of 
$G$ and connect all nodes in $\delta B \cap V_1$ to a source node $s$ and all nodes in 
$\delta B \cap V_2$ to a sink node $t$. \\
We can construct $B := B_1 \cup B_2$ with two \emph{Breadth First Searches} (\BFS). 
One is initialized with all nodes $\delta \cap V_1$ and stops, if $c(B_1)$ would 
exceed $(1+\epsilon)\frac{c(V)}{2} - c(V_2)$. The second is initialized with 
all nodes $\delta \cap V_2$ and stops, if $c(B_2)$ would exceed 
$(1+\epsilon)\frac{c(V)}{2} - c(V_1)$. The two \BFS~only touch nodes of $V_1$ resp. $V_2 \Rightarrow$
$B_1 \subseteq V_1$ and $B_2 \subseteq V_2$. The constraints for the weights of $B_1$
and $B_2$ guarantees that the bipartition is still balanced after a \emph{Max-Flow-Min-Cut}
computation. Connecting $s$ resp. $t$ to all border nodes $\delta B \cap V_1$ resp.
$\delta B \cap V_2$ ensures that a non-cut edge not contained in $G_B$ is not a cut edge after
assigning the \emph{Min-Cut} of $G_B$ to $G$. This also yields to the conclusion that each
minimum $(s,t)$-cutset in $G_B$ leads to a cut smaller or equal to the old cut of $G$. All
concepts are illustrated in \autoref{img:balanced_bipartition}.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{../img/flow_local_search/balanced_bipartitioning.eps}
\caption{Illustration of setting up a flow problem around the cut of graph $G$ \cite{andersen2008algorithm}.}
\label{img:balanced_bipartition}
\end{figure}


\subsubsection{Adaptive Flow Iterations}
\label{sec:adaptive_flow_iterations}

Sanders and Schulz \cite{sanders2011engineering} suggested several heuristics to improve
their basic approach. If the \emph{Max-Flow-Min-Cut} computation on $G_B$ leads to an
improvement in cut, we can apply the method described in Section 
\ref{sec:balanced_bipartitioning} again. An extension of this approach is to iteratively adapt the
size of the flow problem based on the result of the maximum flow computation. For this propose
we define $\epsilon' := \alpha\epsilon$ for a $\alpha \ge 1$ and let the size of $B$ depend
on $\epsilon'$ rather than on $\epsilon$. If we found an improvement on $G$, we
increase $\alpha$ to $\min\{2\alpha, \alpha'\}$ where $\alpha'$ is a predefined upper bound
for $\alpha$. If not, we decrease the size of $\alpha$ to 
$\max\{\frac{\alpha}{2},1\}$. This approach is called
\emph{adaptive flow iterations} \cite{sanders2011engineering}.

\subsubsection{Most Balanced Minimum Cut}
\label{sec:related_mbmc}

Picard and Queyranne \cite{picard1980structure} showed that all minimum $(s,t)$-cutsets 
are computable with one maximum $(s,t)$-flow computations.
To understand the main theorem and the algorithm to compute all minimum $(s,t)$-cutsets we
need the definition of a \emph{closed node set} $C \subseteq V$ of a graph $G$.

\begin{definition}
Let $G = (V,E)$ be a graph and $C \subseteq V$. $C$ is called a closed node set iff the 
condition $u \in C$ implies that for all edges $(u,v) \in E$ also $v \in C$.
\end{definition}

A \emph{closed node set} is illustrated in \autoref{img:closed_node_set}. A simple observation
is that all nodes on a cycle have to be in the same \emph{closed node set} per definition. Therefore,
we can contract all \emph{Strongly Connected Components} (SCC) of $G$ with a linear time algorithm
proposed by Tarjan \cite{tarjan1972depth} and sweep to the reverse
topological order of the contracted graph to enumerate all \emph{closed node sets}. Note, if
we contract all SCC of $G$ the resulting graph is a \emph{Directed Acyclic Graph} (DAC), therefore 
a topological order exists.
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{../img/flow_local_search/closed_node_set.eps}
\caption{Nodes $C = \{s,a,b,c\}$ illustrates a \emph{closed node set} in a graph $G$ (left side).
         After contracting all \emph{Strongly Connected Components}, we can enumerate all
         \emph{closed node sets} of $G$ by sweeping in reverse topological order to the
         contracted graph (right side).}
\label{img:closed_node_set}
\end{figure}
With the Theorem of Picard and Queyranne \cite{picard1980structure} we are able to enumerate
all minimum $(s,t)$-cuts of $G$ with one maximum flow computation.

\begin{theorem}
\label{theorem:mbmc}
There is a $1$-$1$ correspondence between the minimum $(s,t)$-cuts of a graph and the closed node
sets containing $s$ in the residual graph of a maximum $(s,t)$-flow.
\end{theorem}

All \emph{closed node sets} in the residual graph of $G$ induced a minimum $(s,t)$-cutset on $G$.
They can be calculated with the algorithm described above having the residual graph of
$G$ as input. The running time of the algorithm is \BigO{|V| + |E|}. \\
A common problem of the \emph{adaptive flow iteration} approach (see Section \ref{sec:adaptive_flow_iterations}) is
that searching with a large $\alpha$ often leads to cuts in $G$ which violates the balanced constraints. 
We are able with this technique to convert a infeasible solution into a feasible by finding
the \emph{Most Balanced Minimum Cut} (MBMC) with one maximum flow computation.


\subsubsection{Active Block Scheduling}
\label{sec:abs}
\emph{Active Block Scheduling} is a \emph{quotient graph style refinement} technique for
$k$-way partitions \cite{holtgrewe2010engineering,sanders2011engineering}. 
The algorithm is organized in rounds and executes a two-way 
local improvement algorithm on each pair of 
blocks in the \emph{quotient graph} where at least one of both is \emph{active}. 
Initial all blocks are \emph{active}. A block becomes \emph{inactive}, 
if its boundary did not change in a round. The algorithm
terminates, if all blocks are \emph{inactive}. \\
Fiduccia and Mattheyses \cite{fiduccia1988linear} introduces a linear time
two-way local search heuristic, called \emph{FM}, 
which is fundamental for many graph partitioning algorithms.
They define the gain $g(v)$ of a node $v \in V$ as the reduction of the cut metric, when
moving $v$ from its current block to its counterpart block. By maintaining the gains of the
nodes in a special datastructure, called \emph{bucket queue}, they are able to find a maximum
gain node in constant time. After moving a maximum gain node they are also able to update the
datastructure in time equal to the number of adjacent nodes.\\
The local improvement algorithm (for \emph{Active Block Scheduling}) can either 
be a \emph{FM} local search or a flow-based approach or even a combination of 
boths as proposed by Sanders and Schulz \cite{sanders2011engineering}. \\

\todo{integrate improvement table for alpha}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Hypergraph Partitioning}

\subsubsection{Multilevel Paradigm}

\subsubsection{KaHyPar - $n$-Level Hypergraph Partitioning}
\label{sec:kahypar}