%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Maximum Flow Problem}
\label{sec:max_flow}

The first serious analysis of the maximum flow problem emerged in 1955 during 
a study of transportation and communication networks by Harris \cite{harris1955}. 
He formulate the problem as follows: \\
\emph{Consider a rail network connecting two cities by way of a number of
intermediate cities, where each link of the network has a number assigned to
it representing its capacity. Assuming a steady state condition, find a maximal
flow from one given city to the other.} \\
He generalizes his model of railway traffic flow to the today known maximum 
flow problem. \\
Given a graph $G = (V,E,c)$ with capacity function $c: E \rightarrow \mathbb{R}_+$ and a source 
$s \in V$ and a sink $t \in V$. The maximum flow problem is about finding 
the maximum amount of flow from $s$ to $t$ in $G$. A flow is a function 
$f: E \rightarrow \mathbb{R}_+$, which have to satisfy the following constraints:
\begin{enumerate}
\item $\forall (u,v) \in E: f(u,v) \le c(u,v)$ (capacity constraint)
\item $\forall v \in V \setminus \{s,t\}: \sum_{(u,v) \in E} f(u,v) = \sum_{(v,u) \in E} f(v,u)$ (conservation of flow constraint)
\end{enumerate}
The capacity constraint restricts the flow on an edge $(u,v)$ by its capacity 
$c(u,v)$. Whereas the conservation of flow constraint ensures that the amount
of flow entering a node $v \in V \setminus \{s,t\}$ is the same as leaving a node.
The value of the flow is defined as $|f| = \sum_{(s,v) \in E} f(s,v) = \sum_{(v,t) \in E} f(v,t)$.
A flow $f$ is maximal, if there exists no other flow $f'$ in $G$ with $|f'| > |f|$. \\
Another useful construct in connection with maximum flows, is the concept of the
\emph{residual graph} $G_f$ and the \emph{residual capacity} $r_f$ of a flow function $f$ on graph $G$.
The \emph{residual capacity} $r_f: V \times V \rightarrow \mathbb{R}_+$ is defined as follows:
\begin{enumerate}
\item $\forall (u,v) \in E: r_f(u,v) = c(u,v) - f(u,v)$
\item $\forall (u,v) \in E:$ If $(v,u) \notin E$, then $r_f(v,u) = f(u,v)$
\item For all $(u,v) \in V \times V$ with $(u,v) \notin E$ and $(v,u) \notin E$ the
      \emph{residual capacity} is $r_f(u,v) = 0$. 
\end{enumerate}
For a edge $e = (u,v) \in E$ the residual capacity $r_f(u,v)$ is the remaining amount of 
flow which could be send over edge $e$. For each reverse edge $\overleftarrow{e} \notin E$ the
residual capacity $r_f(\overleftarrow{e})$ is the amount of flow which is send over $e$.
The \emph{residual graph} $G_f = (V,E_f,r_f)$ is the network containing all $(u,v) \in V \times V$
with $r_f(u,v) > 0$. More formal $E_f = \{(u,v)\ |\ r_f(u,v) > 0, (u,v) \in V \times V\}$.
\autoref{img:maximum_flow_example}~illustrates all presented concepts.

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{../img/maximum_flow/maximum_flow_example.eps}
\caption{Figure illustrates concepts related to the maximum flow problem. A valid flow $f$ 
(red values) from $s$ to $t$ on a graph $G$ is shown on the left side. The corresponding
\emph{residual graph} $G_f$ with its \emph{residual capacities} (black values) 
is illustrated on the right side. The red highlighted path represents an \emph{augmenting path}
in $G$.}
\label{img:maximum_flow_example}
\end{figure}


\subsubsection{Augmenting-Path Algorithms}
\label{sec:aug_path}

An \emph{augmenting path} $P = \{v_1,\ldots,v_k\}$ is a path in $G_f$ with $v_1 = s$ and 
$v_k = t$ \cite{edmonds1972theoretical}. \autoref{img:maximum_flow_example}~illustrates such a path.
Since all $(v_i,v_{i+1}) \in G_f \Rightarrow r_f(v_i,v_{i+1}) > 0$. 
Therefore, we can increase the flow on all edges $(v_i,v_{i+1})$ by 
$\Delta f = \min_{i \in [1,\ldots,k-1]} r_f(v_i,v_{i+1})$. It can be shown that $f$ is not a
maximum flow, if an \emph{augmenting path} exists in $G_f$ \cite{edmonds1972theoretical}. \\
One way to calculate a maximum flow $f$ is to find \emph{augmenting paths} in $G_f$ as
long as their exist one. The algorithm was established by Ford and Fulkerson \cite{ford1956maximal} and
consists of two phases. First, we search for an \emph{augmenting path} $P = \{v_1,\ldots,v_k\}$
from $s$ to $t$, e.g. with a simple \DFS. In the \emph{augmentation} step, we increase the flow on each
edge $(v_i,v_{i+1})$ by $\Delta f$ and decrease the flow on each reverse edge $(v_{i+1},v_i)$
by $\Delta f$. If the capacities are integral, the algorithm always terminates. Since, we can find an \emph{augmenting
path} in $G_f$ with a simple \DFS~in time \BigO{|V|+|E|} and we can increase the
flow on every path by at least one, the running time of the algorithm can be bounded by \BigO{|E||f_{max}|}.
We can construct instances, where the running time is \BigO{|E||f_{max}|} or even the maximum flow $|f_{max}|$ 
is exponential in the problem size. \\
Edmond and Karp \cite{edmonds1972theoretical} improved Ford \& Fulkerson algorithm by increasing the flow
along an \emph{augmenting path} of minimal length. A shortest path from $s$ to $t$ in a 
graph with unit lengths can be found by a simple \BFS~calculation. It can be shown, that the
total number of \emph{augmentations} is \BigO{|V||E|}. The running time of Edmond \& Karps
maximum flow algorithm is then given by \BigO{|V||E|^2}. A sample execution of the algorithm
is presented in \autoref{img:edmond_karp_example}.

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{../img/maximum_flow/edmond_karp_example.eps}
\caption{Sample execution of Edmond \& Karps maximum flow algorithm \cite{edmonds1972theoretical}.
         The network $G$ with its capacities $c$ (black values) and flow $f$ (red values) is illustrated
         on the left side. The residual graph $G$ with its \emph{residual capacities} $r_f$ (black values)
         is presented on the right side. In each step the current \emph{augmenting path} in $G_f$ is highlighted
         by a red path. }
\label{img:edmond_karp_example}
\end{figure}

\todo{recap cacapcity scaling}


\subsubsection{Push-Relabel Algorithm}
\label{sec:push_relabel}

\subsubsection{Applications}
\label{sec:applications}

The \emph{Max-Flow-Min-Cut}-Theorem is fundamental for many applications related to the maximum
flow problem \cite{ford1956maximal}.

\begin{theorem}
The value of a maximum $(s,t)$-flow obtainable in a graph $G$ is equal with the weight
of the minimum cutset in $G$ seperating $s$ and $t$.
\end{theorem}

Let $f$ be a maximum flow in a graph $G = (V,E,\omega)$ with $s \in V$ and $t \in V$. 
Further, let $A$ be the set containing all $v \in V$, which are \emph{reachable} from $s$
in $G_f$. A node $v$ is \emph{reachable} from a node $u$, if there exists a path from $u$
to $v$. Then the set of all cut edges between the bipartition $(A,V\setminus A)$ 
is a minimum-weight $(s,t)$-cutset \cite{ford2015flows}. $A$ can be calculated with a simple \BFS~in $G_f$ starting
from $s$. \\
From this analogy many solutions for related problems arose. Samples are listed below:
\begin{enumerate}
\item Maximum Bipartite-Matching
\item Minimum-Weight Vertex Seperator
\item Number of Edge-Disjoint Paths
\item Number of Vertex-Disjoint Paths
\end{enumerate}
Solutions for those problems sometimes involves a transformation $T$ of the graph $G$
into a flow network $T(G)$, such that the \emph{Max-Flow-Min-Cut}-Theorem is applicable. 
A problem important for this work is to find a minimum-weight $(s,t)$-vertex seperator
in a graph $G = (V,E,c)$ with $c: V \rightarrow \mathbb{R}_+$.

\begin{definition}
Let $G = (V,E,c)$ be a graph with $c: V \rightarrow \mathbb{R}_+$. $S \subseteq V$
is a vertex seperator for non-adjacent verticies $s \in V$ and $t \in V$ if the
removal of $S$ from graph $G$ seperates $s$ and $t$ ($s$ not \emph{reachable} from $t$).
A vertex seperator $S$ is a minimum-weight $(s,t)$-vertex seperator, if for all $S' \subseteq V$
$c(S) \le c(S')$.
\end{definition}

We can calculate a minimum-weight $(s,t)$-vertex seperator with a maximum flow
calculation in the following flow network (\todo{reference}):

\begin{definition}
\label{def:vertex_seperator_transformation}
Let's denote with $T_V$ the transformation of a graph $G = (V,E,c)$ into 
a flow network $T_V(G) = (V_V, E_V, c_V)$. $T_V$ is defined as follows:
\begin{enumerate}
\item $V_V = \bigcup\limits_{v \in V}\ \{v', v''\}$
\item $\forall v \in V$ we add a directed edge $(v',v'')$
      with capacity $c_V(v',v'') = c(v)$
\item $\forall (u,v) \in E$ we add two directed edges $(u'', v')$ and 
      $(v'', u')$ with capacity $c_V(u'', v') = c_V(v'', u') = \infty$.
\end{enumerate} 
\end{definition}

The vertex seperator problem and transformation $T_V(G)$ are illustrated in \autoref{img:vertex_seperator_example}.
Obviously no edge between two adjacent nodes can be in a minimum-capacity $(s,t)$-cutset of $T_V(G)$,
because for all those edges the capacity is $\infty$. Therefore, the cutset must consist
of edges of the form $(v',v'')$. A minimum-weight $(s,t)$-vertex seperator can be calculated by
finding a maximum flow in $T_V(G)$, finding the minimum-capacity $(s,t)$-cutset with the procedure
described above and then map each cut edge $(v',v'')$ to their corresponding node in $v$.

\todo{Describing multi-source and multi-sink flow problems}

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{../img/maximum_flow/vertex_seperator_example.eps}
\caption{ Illustration of the vertex seperator problem and the transformation $T_V(G)$ in which
          we can find a minimum vertex seperator with maximum flow computation. }
\label{img:vertex_seperator_example}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Modelling Flows on Hypergraphs}
\label{sec:related_model_flow}

\subsubsection{Model Hypergraphs as Graphs}
\label{sec:hypergraph_to_graph}

\subsubsection{Transforming Hypergraphs to Flow Networks}
\label{sec:related_lawler}

Let's consider the \emph{bipartite graph} representation $G$ of a hypergraph $H$ \cite{HuMoerder85}.
Each hyperedge $e$ is modeled as a star node with an edge to all $v \in e$.
Hu and Moerder \cite{HuMoerder85} introduced node capacities in $G$. Each hyperedge
node $e$ has a capacity equal to $\omega(e)$ and each hypernode node infinity capacity. 
Further, they showed that a minimum-weight $(S,T)$-vertex seperator in $G$
is equal with a minimum-weight $(S,T)$-cutset of a hypergraph $H$. 
Finding such a seperator is a flow problem and can be calculated with the flow network \ShortT{L} 
presented by Lawler \cite{lawler1973}:

\begin{definition}
Let's denote with $T_L$ the transformation of a hypergraph \HypergraphDef~into 
a flow network \T{L} proposed by Lawler \cite{lawler1973}. \ShortT{L} is defined as follows:
\begin{enumerate}
\item $V_L = V \cup \bigcup\limits_{e \in E}\ \{e', e''\}$
\item $\forall e \in E$ we add a directed edge $(e',e'')$ 
      with capacity $c_H(e',e'') = \omega(e)$
\item $\forall v \in V$ we add two directed edges $(v, e')$ and 
      $(e'', v),\ \forall e \in I(v)$ with 
      capacity $c_L(v, e') = c_L(e'',v) = \infty$.
\end{enumerate} 
\end{definition}

An example of this transformation is shown in \autoref{img:lawler_transformation}.
\ShortT{L} is nearly equivalent to the transformation $T_V(G)$ described in Defintion \autoref{def:vertex_seperator_transformation}
except that we do not have to split the hypernodes $v \in V$ into $(v',v'')$. This is due to the fact, that
a hypernode cannot be in a minimum-capacity $(S,T)$-vertex seperator, because each $v \in V$ has
infinity capacity \cite{HuMoerder85}.
Therefore, a minimum-capacity $(S,T)$-cutset in \ShortT{L} is equal to a minimum $(S,T)$-vertex seperator $G$.
The resulting graph \ShortT{L} has $|V_L| = 2|V| + |E|$ nodes and $|E_L| = 2(\bar{e}+1)|E|$ edges, where
$\bar{e}$ is the average size of a hyperedge \cite{pistorius2003}. Using \emph{Edmond-Karps}
maximum flow algorithm (see Section \ref{sec:aug_path}) on flow network \ShortT{L} 
takes time \BigO{|V|^2|E|^2} \cite{lawler1973}. \\
A minimum-weight $(S,T)$-cutset of $H$ can be found by simlpy mapping the minimum-capacity
$(S,T)$-cutset to their corresponding hyperedges in $H$ (see Section \ref{sec:applications}). 
The corresponding bipartition are all hypernodes $v \in V$ \emph{reachable} from $S$ in the 
\emph{residual graph} of \ShortT{L} and the counterpart are all hypernodes not \emph{reachable}
from $S$ (\todo{proof? reference?}). \\
In this thesis we often have to mix up nodes and edges of $H$ and \ShortT{L}. If we use
$v \in V_L$, there also exist a corresponding $v \in V$. $v$ can be used in both contexts.
For all $e \in E$ there exists two corresponding nodes $e',e'' \in V_L$. $e'$ 
is called \emph{incomming hyperedge node} and $e''$ is called \emph{outgoing hyperedge node}. 
In some cases we need to treat $e',e'' \in V_L$ the same way as their corresponding 
hyperedge $e \in E$. E.g. $e_1' \cap e_2'$ or $e_1'' \cap e_2'$ should be the same as $e_1 \cap e_2$.
However, it should be clear out of the context which terminology is used.


\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{../img/network_transformation/lawler_transformation.eps}
\caption{Transformation of a hypergraph into a equivalent flow network by Lawler \cite{lawler1973}. Note,
capacity of the black edges in the flow network is $\infty$.}
\label{img:lawler_transformation}
\end{figure}

\subsubsection{Implicit Flow Calculation on Hypergraphs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Max-Flow-Min-Cut Based Local Search on Graphs}
\label{sec:flow_local_search_graph}

It seems naturals to utilize maximum flow computations to improve a 
partition of a graph. Lang and Rao \cite{lang2004flow} uses an approach,
called \emph{Max-Flow Qoutient-cut Improvement} (MQI), to improve the cut
of a graph when metrics such as \emph{expansion} or \emph{conductance}
are used. For a given bipartition $(S,\bar{S})$, they find the best 
improvement among all bipartitions $(S',\bar{S'})$ such that $S' \subset S$
by constructing a flow problem. Andersen and Lang \cite{andersen2008algorithm}
proposed a flow-based improvement algorithm, called \emph{Improve},
which works similiar as MQI, but did not restrict the output of the 
partition on $S' \subset S$. However, both techniques can not guarantee 
that the resulting bipartition is balanced and only are applicable for $k=2$. \\
Schulz and Sanders \cite{sanders2011engineering} integrate flow-based approaches 
in their \emph{multilevel graph partitioning} framework \emph{KaFFPa}. In general,
they build a flow problem around a region $B$ of the cut and connect the \emph{border} 
of $B$ with the source resp. sink. $B$ is defined in such a way that the flow computation
yields to a feasible cut in the original graph. Many ideas from this work are used in this
thesis and adapted to work on hypergraphs. Therefore, we will give a detailed description
of the fundamental concepts and advanced techniques to improve the cut of a graph.

\todo{define expansion and conductance in preliminaries for graphs}

\subsubsection{Flow-Based Balanced Partitioning}
\label{sec:balanced_bipartitioning}
Let $(V_1,V_2)$ be a balanced bipartition of a graph $G = (V,E,c,\omega)$ such that $V_1$ and
$V_2$ is smaller than $(1+\epsilon)\frac{c(V)}{2}$ for $\epsilon > 0$. Further, $P(v) = 1$, if $v \in V_1$ and
$P(v) = 2$, otherwise. We will now explain how to improve a given
bipartition with flow computations. This technique can also be used on a $k$-way 
partition by applying the approach on two adjacent blocks in the qoutient graph \cite{sanders2011engineering}. \\
Let's define with $\delta := \{ u\ |\ \exists (u,v) \in E: P(u) \neq P(v) \}$ the set of nodes
around the cut of $G$. For a set $B \subseteq V$ we define its border 
$\delta B := \{u \in B\ |\ \exists (u,v) \in E: v \notin B\}$ and the induced subgraph
$G(B) = (B,E_B,c,\omega)$ with $E_B = \{(u,v) \in E\ |\ u, v \in B\}$. 
The basic idea is to build a flow problem $G(B)$ around all cut nodes $\delta$ of 
$G$ and connect all nodes in $\delta B \cap V_1$ to a source node $s$ and all nodes in 
$\delta B \cap V_2$ to a sink node $t$. \\
We can construct $B := B_1 \cup B_2$ with two \emph{Breadth First Searches} (\BFS). 
One is initialized with all nodes $\delta \cap V_1$ and stops, if $c(B_1)$ would 
exceed $(1+\epsilon)\frac{c(V)}{2} - c(V_2)$. The second is initialized with 
all nodes $\delta \cap V_2$ and stops, if $c(B_2)$ would exceed 
$(1+\epsilon)\frac{c(V)}{2} - c(V_1)$. The two \BFS~only touch nodes of $V_1$ resp. $V_2 \Rightarrow$
$B_1 \subseteq V_1$ and $B_2 \subseteq V_2$. The constraints for the weights of $B_1$
and $B_2$ guarantees that the bipartition is still balanced after a \emph{Max-Flow-Min-Cut}
computation. Connecting $s$ resp. $t$ to all border nodes $\delta B \cap V_1$ resp.
$\delta B \cap V_2$ ensures that a non-cut edge not contained in $G(B)$ is not a cut edge after
assigning the \emph{Min-Cut} of $G(B)$ to $G$. This also yields to the conclusion that each
$(s,t)$ \emph{Min-Cut} in $G(B)$ leads to a cut smaller or equal to the old cut of $G$. All
concepts are illustrated in \autoref{img:balanced_bipartition}.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{../img/flow_local_search/balanced_bipartitioning.eps}
\caption{Illustration of setting up a flow problem around the cut of graph $G$ \cite{andersen2008algorithm}.}
\label{img:balanced_bipartition}
\end{figure}

\todo{define qoutient graph and subgraph in preliminaries}

\subsubsection{Adaptive Flow Iterations}
\label{sec:adaptive_flow_iterations}

Sanders and Schulz \cite{sanders2011engineering} suggested several heuristics to improve
their basic approach. If the \emph{Max-Flow-Min-Cut} computation on $G(B)$ leads to an
improvement on the cut metric of $G$, we can again apply the method described in Section 
\ref{sec:balanced_bipartitioning}. An extension of this approach is to iteratively adapt the
size of the flow problem based on the result of the maximum flow computation. For this propose
we define $\epsilon' := \alpha\epsilon$ for a $\alpha \ge 1$ and let the size of $B$ depend
on $\epsilon'$ rather than on $\epsilon$. If we found an improvement on $G$ with $G(B)$, we
increase $\alpha$ to $\min\{2\alpha, \alpha'\}$ where $\alpha'$ is a predefined upper bound
for $\alpha$. If the \emph{Max-Flow-Min-Cut} computation on $G(B)$ did not yield to an 
improved cut on $G$ or the resulting bipartition did not fullfill the balance constraints we
decrease the size of $\alpha$ to $\max\{\frac{\alpha}{2},1\}$. This approach is called
\emph{adaptive flow iterations} \cite{sanders2011engineering}.

\subsubsection{Most Balanced Minimum Cut}
\label{sec:related_mbmc}

Picard and Queyranne \cite{picard1980structure} showed that all minimum $(s,t)$-cuts 
are computable with one $(s,t)$ maximum flow computations on the residual graph of $G$.
To understand the main theorem and the algorithm to compute all minimum $(s,t)$-cuts we
need the definition of a \emph{closed node set} $C \subseteq V$ of a graph $G$.

\begin{definition}
Let $G = (V,E)$ be a graph and $C \subseteq V$. $C$ is called a closed node set iff the 
condition $u \in C$ implies that for all edges $(u,v) \in E$ also $v \in C$.
\end{definition}

A \emph{closed node set} is illustrated in \autoref{img:closed_node_set}. A simple observation
is that all nodes on a cycle have to be in the same \emph{closed node set} per definition. Therefore,
we can contract all \emph{Strongly Connected Components} (SCC) in $G$ with a simple linear time algorithm
proposed by Tarjan (\todo{reference see \cite{sanders2011engineering}}) and sweep to the reverse
topological order of the contracted graph to enumerate all \emph{closed node sets}. Note, if
we contract all SCC in $G$ the resulting graph is a \emph{Directed Acyclic Graph} (DAC), therefore 
a topological order exists.
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{../img/flow_local_search/closed_node_set.eps}
\caption{Nodes $C = \{s,a,b,c\}$ illustrates a \emph{closed node set} in a graph $G$ (left side).
         After contracting all \emph{Strongly Connected Components}, we can enumerate all
         \emph{closed node sets} of $G$ by sweeping in reverse topological order to the
         contracted graph (right side).}
\label{img:closed_node_set}
\end{figure}

With the Theorem of Picard and Queyranne \cite{picard1980structure} we are able to enumerate
all minimum $(s,t)$-cuts of $G$ with one maximum flow computation.

\begin{theorem}
\label{theorem:mbmc}
There is a $1$-$1$ correspondence between the minimum $(s,t)$-cuts of a graph and the closed node
sets containing $s$ in the residual graph of a maximum $(s,t)$-flow.
\end{theorem}

All \emph{closed node sets} in the residual graph of $G$ induced a minimum $(s,t)$-cut on $G$.
They can be calculated with the algorithm described above having the residual graph of
$G$ as input. The running time of the algorithm is \BigO{|V| + |E|}. \\
A common problem of the \emph{adaptive flow iteration} approach (see Section \ref{sec:adaptive_flow_iterations}) is
that searching with a large $\alpha$ often leads to cuts which violates the balanced constraints
in $G$. We are able with this technique to make a infeasible solution feasible by finding
a \emph{Most Balanced Minimum Cut} (MBMC) in $G$ with one maximum flow computation on $G(B)$.


\todo{define contraction, strongly connected components and cycles in graph in preliminaries}

\subsubsection{Active Block Scheduling}
\label{sec:abs}
\emph{Active Block Scheduling} is a \emph{quotient graph style refinement} technique for
$k$-way partitions \cite{holtgrewe2010engineering,sanders2011engineering}. 
The algorithm is organized in rounds and executes a two-way 
local improvement algorithm on each pair of 
blocks in the \emph{quotient graph} where at least one of both is \emph{active}. 
Initial all blocks are \emph{active}. A block becomes \emph{inactive}, 
if its boundary did not change in a round. The algorithm
terminates, if all blocks are \emph{inactive}. \\
Fiduccia and Mattheyses \cite{fiduccia1988linear} introduces a linear time
two-way local search heuristic, called \emph{FM} local search, 
which is fundamental for many graph partitioning refinement algorithms.
They define the gain $g(v)$ of a node $v \in V$ as the reduction of the cut metric, when
moving $v$ from its current block to its counterpart block. By maintaining the gains of the
nodes in a special datastructure, called \emph{bucket queue}, they are able to find a maximum
gain node in constant time. After moving a maximum gain node they are also able to update their
datastructure in time equal to the number of adjacent nodes.\\
The local improvement algorithm (for \emph{Active Block Scheduling}) can either 
be a \emph{FM} local search or a flow-based approach or even a combination of 
boths as proposed by Sanders and Schulz \cite{sanders2011engineering}. \\

\todo{integrate improvement table for alpha}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Hypergraph Partitioning}

\subsubsection{Multilevel Paradigm}

\subsubsection{KaHyPar - $n$-Level Hypergraph Partitioning}
\label{sec:kahypar}